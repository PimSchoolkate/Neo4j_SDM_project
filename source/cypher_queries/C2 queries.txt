first connect all authors together that have some node in common (e.g. paper or affiliation)

match (a:Author) - [] -() - [] - (a2:Author)
where a <> a2
with a, a2
merge (a) - [:knows] -(a2)

second get the gds.graph

CALL gds.graph.create(
    'myGraph',
    'Author',
    {
        knows: {
            orientation: 'UNDIRECTED'
        }
    }
)

Third call the louvain function

CALL gds.louvain.stream('myGraph')
YIELD nodeId, communityId, intermediateCommunityIds
RETURN gds.util.asNode(nodeId).name AS name, communityId, intermediateCommunityIds
ORDER BY name ASC

res: name	communityId	intermediateCommunityIds

Fourth call the stats on the louvain function

CALL gds.louvain.stats('myGraph')
YIELD communityCount

res: communityCount